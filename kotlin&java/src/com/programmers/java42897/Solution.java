// 문제 링크 : https://programmers.co.kr/learn/courses/30/lessons/42897
// 도둑질

// 어.. 첫번째 집을 무조건 훔치지 않는 경우(dp[n][0])의 배열과 훔치는 경우의 배열(dp[n][1])로 나눠서
// 메모이제이션을 활용하였다.
// 지금보니 원래 하려던 방식과 가로/세로가 뒤바꿨다;; 설명을 재대로 쓰고있다.

// 기본적으로는 계산을 연속적으로 같은 칸을 오르지 못하는 조건의? 계단오르기 문제처럼 해결하였다.
// (현재 집을 훔치지 않는 경우의 최대 값)과 (현재 집을 훔칠 경우의 최대 값) 중 더 큰 값을 저장한다.
// (이전 집까지의 최대 값)과 (전전집의 최대 값 + 현재 집의 돈) 중 더 큰 값을 저장하면 위와 같이 작동한다.

package com.programmers.java42897;

import java.util.Arrays;

class Solution {
    public int solution(int[] money) {
        // [각 집까지의 최대 얻을 수 있는 돈][첫번째 집을 무조건 훔칠 때, 그렇지 않았을 때]
        int len = money.length;
        int[][] dp = new int[len][2];
        dp[1][1] = money[0];

        // 각 집을 방문하면서 각 경우의 수 계산하기
        for (int i = 2; i<len; i++){
            dp[i][0] = Math.max(dp[i-1][0], dp[i-2][0]+money[i-1]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-2][1]+money[i-1]);
        }

        // 마지막 집은 조금 특별하다.
        // (첫번째 집을 훔치지 않은 경우에서 마지막 전집의 최대값)과
        // (첫번째 집을 훔치지 않은 경우에서 마지막 전전집의 최대값 + 마지막 집의 돈)과
        // (첫번째 집을 훔친 경우에서 마지막 전집의 최대값)을 비교하여 가장 큰 값을 출력한다.
        int answer = Math.max(dp[len-1][0], dp[len-2][0]+money[len-1]);
        answer = Math.max(answer, dp[len-1][1]);
        System.out.println(Arrays.deepToString(dp));
        return answer;
    }
}

//정확성  테스트
//테스트 1 〉	통과 (1.01ms, 77.7MB)
//테스트 2 〉	통과 (0.17ms, 74MB)
//테스트 3 〉	통과 (0.11ms, 75.9MB)
//테스트 4 〉	통과 (0.04ms, 75.9MB)
//테스트 5 〉	통과 (0.18ms, 78.8MB)
//테스트 6 〉	통과 (0.13ms, 76.3MB)
//테스트 7 〉	통과 (0.10ms, 78.2MB)
//테스트 8 〉	통과 (0.08ms, 80.9MB)
//테스트 9 〉	통과 (0.16ms, 77.8MB)
//테스트 10 〉	통과 (0.06ms, 73MB)
//효율성  테스트
//테스트 1 〉	통과 (95.72ms, 115MB)
//테스트 2 〉	통과 (94.22ms, 114MB)
//테스트 3 〉	통과 (95.84ms, 115MB)
//테스트 4 〉	통과 (100.62ms, 115MB)
//테스트 5 〉	통과 (55.12ms, 114MB)
//테스트 6 〉	통과 (99.11ms, 115MB)
//테스트 7 〉	통과 (90.36ms, 90.4MB)
//테스트 8 〉	통과 (92.45ms, 90.7MB)
//테스트 9 〉	통과 (47.06ms, 91.5MB)
//테스트 10 〉	통과 (96.17ms, 115MB)
//채점 결과
//정확성: 50.0
//효율성: 50.0
//합계: 100.0 / 100.0